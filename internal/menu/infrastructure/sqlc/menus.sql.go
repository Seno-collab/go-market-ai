// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: menus.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const attachOptionGroupToItem = `-- name: AttachOptionGroupToItem :exec
INSERT INTO menu_item_option_groups(menu_item_id, option_group_id, sort_order)
VALUES ($1, $2, $3)
ON CONFLICT (menu_item_id, option_group_id) DO NOTHING
`

type AttachOptionGroupToItemParams struct {
	MenuItemID    int64
	OptionGroupID int64
	SortOrder     int32
}

func (q *Queries) AttachOptionGroupToItem(ctx context.Context, arg AttachOptionGroupToItemParams) error {
	_, err := q.db.Exec(ctx, attachOptionGroupToItem, arg.MenuItemID, arg.OptionGroupID, arg.SortOrder)
	return err
}

const countMenuItems = `-- name: CountMenuItems :one
SELECT COUNT(*)
FROM menu_items
WHERE restaurant_id = $1 AND (
    $2::boolean IS NULL
    OR is_active = $2::boolean
  )
  AND (
          $3::text = ''
          OR name ILIKE '%' || $3 || '%'
          OR description ILIKE '%' || $3 || '%'
        ) AND (NULLIF($4::text, '') IS NULL
        OR type = $4::menu_item_type)
`

type CountMenuItemsParams struct {
	RestaurantID int32
	IsActive     *bool
	Name         *string
	Type         *string
}

func (q *Queries) CountMenuItems(ctx context.Context, arg CountMenuItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMenuItems,
		arg.RestaurantID,
		arg.IsActive,
		arg.Name,
		arg.Type,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOptionItems = `-- name: CountOptionItems :one
SELECT COUNT(*)
FROM option_items oi
JOIN option_groups og ON og.id = oi.option_group_id
WHERE oi.option_group_id = $1
  AND og.restaurant_id = $2
ORDER BY oi.sort_order, oi.id
`

type CountOptionItemsParams struct {
	OptionGroupID int64
	RestaurantID  int32
}

func (q *Queries) CountOptionItems(ctx context.Context, arg CountOptionItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOptionItems, arg.OptionGroupID, arg.RestaurantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTopicsByRestaurant = `-- name: CountTopicsByRestaurant :one
SELECT COUNT(*) FROM topics WHERE restaurant_id = $1
`

func (q *Queries) CountTopicsByRestaurant(ctx context.Context, restaurantID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countTopicsByRestaurant, restaurantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createComboGroup = `-- name: CreateComboGroup :exec
INSERT INTO combo_groups (
    combo_item_id, name, min_select, max_select, sort_order
)
VALUES ($1, $2, $3, $4, $5)
`

type CreateComboGroupParams struct {
	ComboItemID int64
	Name        string
	MinSelect   int32
	MaxSelect   int32
	SortOrder   int32
}

func (q *Queries) CreateComboGroup(ctx context.Context, arg CreateComboGroupParams) error {
	_, err := q.db.Exec(ctx, createComboGroup,
		arg.ComboItemID,
		arg.Name,
		arg.MinSelect,
		arg.MaxSelect,
		arg.SortOrder,
	)
	return err
}

const createComboGroupItem = `-- name: CreateComboGroupItem :exec
INSERT INTO combo_group_items (
    combo_group_id, menu_item_id,
    price_delta, quantity_default, quantity_min,
    quantity_max, sort_order
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateComboGroupItemParams struct {
	ComboGroupID    int64
	MenuItemID      int64
	PriceDelta      pgtype.Numeric
	QuantityDefault int32
	QuantityMin     int32
	QuantityMax     int32
	SortOrder       int32
}

func (q *Queries) CreateComboGroupItem(ctx context.Context, arg CreateComboGroupItemParams) error {
	_, err := q.db.Exec(ctx, createComboGroupItem,
		arg.ComboGroupID,
		arg.MenuItemID,
		arg.PriceDelta,
		arg.QuantityDefault,
		arg.QuantityMin,
		arg.QuantityMax,
		arg.SortOrder,
	)
	return err
}

const createMenuItem = `-- name: CreateMenuItem :one
INSERT INTO menu_items (
    restaurant_id, topic_id, type, name, description,
    image_url, sku, base_price, is_active, sort_order
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, TRUE, $9)
RETURNING id
`

type CreateMenuItemParams struct {
	RestaurantID int32
	TopicID      *int64
	Type         string
	Name         string
	Description  *string
	ImageUrl     *string
	Sku          *string
	BasePrice    pgtype.Numeric
	SortOrder    int32
}

func (q *Queries) CreateMenuItem(ctx context.Context, arg CreateMenuItemParams) (int64, error) {
	row := q.db.QueryRow(ctx, createMenuItem,
		arg.RestaurantID,
		arg.TopicID,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.Sku,
		arg.BasePrice,
		arg.SortOrder,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createOptionGroup = `-- name: CreateOptionGroup :one
INSERT INTO option_groups (
    restaurant_id, name, min_select, max_select, is_required, sort_order
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateOptionGroupParams struct {
	RestaurantID int32
	Name         string
	MinSelect    int32
	MaxSelect    int32
	IsRequired   bool
	SortOrder    int32
}

func (q *Queries) CreateOptionGroup(ctx context.Context, arg CreateOptionGroupParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOptionGroup,
		arg.RestaurantID,
		arg.Name,
		arg.MinSelect,
		arg.MaxSelect,
		arg.IsRequired,
		arg.SortOrder,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createOptionItem = `-- name: CreateOptionItem :one
INSERT INTO option_items (
    option_group_id, name, linked_menu_item,
    price_delta, quantity_min, quantity_max, sort_order
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateOptionItemParams struct {
	OptionGroupID  int64
	Name           *string
	LinkedMenuItem *int64
	PriceDelta     pgtype.Numeric
	QuantityMin    int32
	QuantityMax    int32
	SortOrder      int32
}

func (q *Queries) CreateOptionItem(ctx context.Context, arg CreateOptionItemParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOptionItem,
		arg.OptionGroupID,
		arg.Name,
		arg.LinkedMenuItem,
		arg.PriceDelta,
		arg.QuantityMin,
		arg.QuantityMax,
		arg.SortOrder,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createTopic = `-- name: CreateTopic :one
INSERT INTO topics (restaurant_id, name, slug, parent_id, sort_order)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, restaurant_id, name, slug, parent_id, sort_order, is_active, created_at, updated_at
`

type CreateTopicParams struct {
	RestaurantID int32
	Name         string
	Slug         *string
	ParentID     *int64
	SortOrder    int32
}

func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, createTopic,
		arg.RestaurantID,
		arg.Name,
		arg.Slug,
		arg.ParentID,
		arg.SortOrder,
	)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Name,
		&i.Slug,
		&i.ParentID,
		&i.SortOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVariant = `-- name: CreateVariant :exec
INSERT INTO menu_item_variants (
    menu_item_id, name, price_delta, is_default, sort_order
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateVariantParams struct {
	MenuItemID int64
	Name       string
	PriceDelta pgtype.Numeric
	IsDefault  bool
	SortOrder  int32
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) error {
	_, err := q.db.Exec(ctx, createVariant,
		arg.MenuItemID,
		arg.Name,
		arg.PriceDelta,
		arg.IsDefault,
		arg.SortOrder,
	)
	return err
}

const deleteComboGroup = `-- name: DeleteComboGroup :exec
DELETE FROM combo_groups WHERE id = $1
`

func (q *Queries) DeleteComboGroup(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteComboGroup, id)
	return err
}

const deleteComboGroupItem = `-- name: DeleteComboGroupItem :exec
DELETE FROM combo_group_items WHERE id = $1
`

func (q *Queries) DeleteComboGroupItem(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteComboGroupItem, id)
	return err
}

const deleteMenuItem = `-- name: DeleteMenuItem :exec
DELETE FROM menu_items WHERE id = $1 AND restaurant_id = $2
`

type DeleteMenuItemParams struct {
	ID           int64
	RestaurantID int32
}

func (q *Queries) DeleteMenuItem(ctx context.Context, arg DeleteMenuItemParams) error {
	_, err := q.db.Exec(ctx, deleteMenuItem, arg.ID, arg.RestaurantID)
	return err
}

const deleteOptionGroup = `-- name: DeleteOptionGroup :exec
DELETE FROM option_groups
WHERE id = $1
  AND restaurant_id = $2
`

type DeleteOptionGroupParams struct {
	ID           int64
	RestaurantID int32
}

func (q *Queries) DeleteOptionGroup(ctx context.Context, arg DeleteOptionGroupParams) error {
	_, err := q.db.Exec(ctx, deleteOptionGroup, arg.ID, arg.RestaurantID)
	return err
}

const deleteOptionItem = `-- name: DeleteOptionItem :exec
DELETE FROM option_items oi
USING option_groups og
WHERE oi.id = $1
  AND oi.option_group_id = og.id
  AND og.restaurant_id = $2
`

type DeleteOptionItemParams struct {
	ID           int64
	RestaurantID int32
}

func (q *Queries) DeleteOptionItem(ctx context.Context, arg DeleteOptionItemParams) error {
	_, err := q.db.Exec(ctx, deleteOptionItem, arg.ID, arg.RestaurantID)
	return err
}

const deleteTopic = `-- name: DeleteTopic :exec
DELETE FROM topics
WHERE id = $1
  AND restaurant_id = $2
`

type DeleteTopicParams struct {
	ID           int64
	RestaurantID int32
}

func (q *Queries) DeleteTopic(ctx context.Context, arg DeleteTopicParams) error {
	_, err := q.db.Exec(ctx, deleteTopic, arg.ID, arg.RestaurantID)
	return err
}

const getComboGroupItems = `-- name: GetComboGroupItems :many
SELECT id, combo_group_id, menu_item_id, price_delta, quantity_default, quantity_min, quantity_max, sort_order, created_at, updated_at
FROM combo_group_items
WHERE combo_group_id = $1
ORDER BY sort_order, id
`

func (q *Queries) GetComboGroupItems(ctx context.Context, comboGroupID int64) ([]ComboGroupItem, error) {
	rows, err := q.db.Query(ctx, getComboGroupItems, comboGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ComboGroupItem
	for rows.Next() {
		var i ComboGroupItem
		if err := rows.Scan(
			&i.ID,
			&i.ComboGroupID,
			&i.MenuItemID,
			&i.PriceDelta,
			&i.QuantityDefault,
			&i.QuantityMin,
			&i.QuantityMax,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullMenu = `-- name: GetFullMenu :many
SELECT
    mi.id, mi.restaurant_id, mi.topic_id, mi.type, mi.name, mi.description, mi.image_url, mi.sku, mi.base_price, mi.is_active, mi.sort_order, mi.created_at, mi.updated_at,
    t.id AS topic_id,
    t.name AS topic_name,
    mv.id, mv.menu_item_id, mv.name, mv.price_delta, mv.is_default, mv.sort_order, mv.created_at, mv.updated_at,
    og.id, og.restaurant_id, og.name, og.min_select, og.max_select, og.is_required, og.sort_order, og.created_at, og.updated_at,
    oi.id, oi.option_group_id, oi.name, oi.linked_menu_item, oi.price_delta, oi.quantity_min, oi.quantity_max, oi.sort_order, oi.is_active, oi.created_at, oi.updated_at,
    cg.id, cg.combo_item_id, cg.name, cg.min_select, cg.max_select, cg.sort_order, cg.created_at, cg.updated_at,
    cgi.id, cgi.combo_group_id, cgi.menu_item_id, cgi.price_delta, cgi.quantity_default, cgi.quantity_min, cgi.quantity_max, cgi.sort_order, cgi.created_at, cgi.updated_at
FROM menu_items mi
LEFT JOIN topics t ON t.id = mi.topic_id
LEFT JOIN menu_item_variants mv ON mv.menu_item_id = mi.id
LEFT JOIN menu_item_option_groups mog ON mog.menu_item_id = mi.id
LEFT JOIN option_groups og ON og.id = mog.option_group_id
LEFT JOIN option_items oi ON oi.option_group_id = og.id
LEFT JOIN combo_groups cg ON cg.combo_item_id = mi.id
LEFT JOIN combo_group_items cgi ON cgi.combo_group_id = cg.id
WHERE mi.restaurant_id = $1
`

type GetFullMenuRow struct {
	ID              int64
	RestaurantID    int32
	TopicID         *int64
	Type            string
	Name            string
	Description     *string
	ImageUrl        *string
	Sku             *string
	BasePrice       pgtype.Numeric
	IsActive        bool
	SortOrder       int32
	CreatedAt       time.Time
	UpdatedAt       time.Time
	TopicID_2       *int64
	TopicName       *string
	ID_2            *int64
	MenuItemID      *int64
	Name_2          *string
	PriceDelta      pgtype.Numeric
	IsDefault       *bool
	SortOrder_2     int
	CreatedAt_2     pgtype.Timestamptz
	UpdatedAt_2     pgtype.Timestamptz
	ID_3            *int64
	RestaurantID_2  int
	Name_3          *string
	MinSelect       int
	MaxSelect       int32
	IsRequired      *bool
	SortOrder_3     int
	CreatedAt_3     pgtype.Timestamptz
	UpdatedAt_3     pgtype.Timestamptz
	ID_4            *int64
	OptionGroupID   *int64
	Name_4          *string
	LinkedMenuItem  *int64
	PriceDelta_2    pgtype.Numeric
	QuantityMin     int
	QuantityMax     int32
	SortOrder_4     int
	IsActive_2      *bool
	CreatedAt_4     pgtype.Timestamptz
	UpdatedAt_4     pgtype.Timestamptz
	ID_5            *int64
	ComboItemID     *int64
	Name_5          *string
	MinSelect_2     int
	MaxSelect_2     int
	SortOrder_5     int
	CreatedAt_5     pgtype.Timestamptz
	UpdatedAt_5     pgtype.Timestamptz
	ID_6            *int64
	ComboGroupID    *int64
	MenuItemID_2    *int64
	PriceDelta_3    pgtype.Numeric
	QuantityDefault int
	QuantityMin_2   int
	QuantityMax_2   int32
	SortOrder_6     int
	CreatedAt_6     pgtype.Timestamptz
	UpdatedAt_6     pgtype.Timestamptz
}

func (q *Queries) GetFullMenu(ctx context.Context, restaurantID int32) ([]GetFullMenuRow, error) {
	rows, err := q.db.Query(ctx, getFullMenu, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFullMenuRow
	for rows.Next() {
		var i GetFullMenuRow
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.TopicID,
			&i.Type,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Sku,
			&i.BasePrice,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TopicID_2,
			&i.TopicName,
			&i.ID_2,
			&i.MenuItemID,
			&i.Name_2,
			&i.PriceDelta,
			&i.IsDefault,
			&i.SortOrder_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.ID_3,
			&i.RestaurantID_2,
			&i.Name_3,
			&i.MinSelect,
			&i.MaxSelect,
			&i.IsRequired,
			&i.SortOrder_3,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
			&i.ID_4,
			&i.OptionGroupID,
			&i.Name_4,
			&i.LinkedMenuItem,
			&i.PriceDelta_2,
			&i.QuantityMin,
			&i.QuantityMax,
			&i.SortOrder_4,
			&i.IsActive_2,
			&i.CreatedAt_4,
			&i.UpdatedAt_4,
			&i.ID_5,
			&i.ComboItemID,
			&i.Name_5,
			&i.MinSelect_2,
			&i.MaxSelect_2,
			&i.SortOrder_5,
			&i.CreatedAt_5,
			&i.UpdatedAt_5,
			&i.ID_6,
			&i.ComboGroupID,
			&i.MenuItemID_2,
			&i.PriceDelta_3,
			&i.QuantityDefault,
			&i.QuantityMin_2,
			&i.QuantityMax_2,
			&i.SortOrder_6,
			&i.CreatedAt_6,
			&i.UpdatedAt_6,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMenuItemByID = `-- name: GetMenuItemByID :one
SELECT id, restaurant_id, topic_id, type, name, description, image_url, sku, base_price, is_active, sort_order, created_at, updated_at
FROM menu_items
WHERE id = $1 and restaurant_id = $2
`

type GetMenuItemByIDParams struct {
	ID           int64
	RestaurantID int32
}

func (q *Queries) GetMenuItemByID(ctx context.Context, arg GetMenuItemByIDParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, getMenuItemByID, arg.ID, arg.RestaurantID)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.TopicID,
		&i.Type,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Sku,
		&i.BasePrice,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMenuItemsByRestaurant = `-- name: GetMenuItemsByRestaurant :many
SELECT id, restaurant_id, topic_id, type, name, description, image_url, sku, base_price, is_active, sort_order, created_at, updated_at
FROM menu_items
WHERE restaurant_id = $1
  AND (
          $2::boolean IS NULL
          OR is_active = $2::boolean
      )
  AND (
          $3::text = ''
          OR name ILIKE '%' || $3 || '%'
          OR description ILIKE '%' || $3 || '%'
        ) AND (NULLIF($4::text, '') IS NULL
        OR type = $4::menu_item_type)
ORDER BY sort_order, id
LIMIT $6 OFFSET $5
`

type GetMenuItemsByRestaurantParams struct {
	RestaurantID int32
	IsActive     *bool
	Name         string
	Type         string
	OffsetValue  int32
	LimitValue   int32
}

func (q *Queries) GetMenuItemsByRestaurant(ctx context.Context, arg GetMenuItemsByRestaurantParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, getMenuItemsByRestaurant,
		arg.RestaurantID,
		arg.IsActive,
		arg.Name,
		arg.Type,
		arg.OffsetValue,
		arg.LimitValue,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.TopicID,
			&i.Type,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Sku,
			&i.BasePrice,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionGroup = `-- name: GetOptionGroup :one
SELECT id, restaurant_id, name, min_select, max_select, is_required, sort_order, created_at, updated_at
FROM option_groups
WHERE id = $1
  AND restaurant_id = $2
`

type GetOptionGroupParams struct {
	ID           int64
	RestaurantID int32
}

func (q *Queries) GetOptionGroup(ctx context.Context, arg GetOptionGroupParams) (OptionGroup, error) {
	row := q.db.QueryRow(ctx, getOptionGroup, arg.ID, arg.RestaurantID)
	var i OptionGroup
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Name,
		&i.MinSelect,
		&i.MaxSelect,
		&i.IsRequired,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionGroupsByItem = `-- name: GetOptionGroupsByItem :many
SELECT og.id, og.restaurant_id, og.name, og.min_select, og.max_select, og.is_required, og.sort_order, og.created_at, og.updated_at
FROM option_groups og
JOIN menu_item_option_groups mig ON mig.option_group_id = og.id
WHERE mig.menu_item_id = $1
  AND og.restaurant_id = $2
ORDER BY og.sort_order, og.id
LIMIT $3 OFFSET $4
`

type GetOptionGroupsByItemParams struct {
	MenuItemID   int64
	RestaurantID int32
	Limit        int32
	Offset       int32
}

func (q *Queries) GetOptionGroupsByItem(ctx context.Context, arg GetOptionGroupsByItemParams) ([]OptionGroup, error) {
	rows, err := q.db.Query(ctx, getOptionGroupsByItem,
		arg.MenuItemID,
		arg.RestaurantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OptionGroup
	for rows.Next() {
		var i OptionGroup
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.Name,
			&i.MinSelect,
			&i.MaxSelect,
			&i.IsRequired,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionItem = `-- name: GetOptionItem :one
SELECT oi.id, oi.option_group_id, oi.name, oi.linked_menu_item, oi.price_delta, oi.quantity_min, oi.quantity_max, oi.sort_order, oi.is_active, oi.created_at, oi.updated_at
FROM option_items oi
JOIN option_groups og ON og.id = oi.option_group_id
WHERE oi.id = $1
  AND og.restaurant_id = $2
`

type GetOptionItemParams struct {
	ID           int64
	RestaurantID int32
}

func (q *Queries) GetOptionItem(ctx context.Context, arg GetOptionItemParams) (OptionItem, error) {
	row := q.db.QueryRow(ctx, getOptionItem, arg.ID, arg.RestaurantID)
	var i OptionItem
	err := row.Scan(
		&i.ID,
		&i.OptionGroupID,
		&i.Name,
		&i.LinkedMenuItem,
		&i.PriceDelta,
		&i.QuantityMin,
		&i.QuantityMax,
		&i.SortOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionItemsByGroup = `-- name: GetOptionItemsByGroup :many
SELECT oi.id, oi.option_group_id, oi.name, oi.linked_menu_item, oi.price_delta, oi.quantity_min, oi.quantity_max, oi.sort_order, oi.is_active, oi.created_at, oi.updated_at
FROM option_items oi
JOIN option_groups og ON og.id = oi.option_group_id
WHERE oi.option_group_id = $1
  AND og.restaurant_id = $2
ORDER BY oi.sort_order, oi.id
LIMIT $3 OFFSET $4
`

type GetOptionItemsByGroupParams struct {
	OptionGroupID int64
	RestaurantID  int32
	Limit         int32
	Offset        int32
}

func (q *Queries) GetOptionItemsByGroup(ctx context.Context, arg GetOptionItemsByGroupParams) ([]OptionItem, error) {
	rows, err := q.db.Query(ctx, getOptionItemsByGroup,
		arg.OptionGroupID,
		arg.RestaurantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OptionItem
	for rows.Next() {
		var i OptionItem
		if err := rows.Scan(
			&i.ID,
			&i.OptionGroupID,
			&i.Name,
			&i.LinkedMenuItem,
			&i.PriceDelta,
			&i.QuantityMin,
			&i.QuantityMax,
			&i.SortOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopic = `-- name: GetTopic :one
SELECT id, restaurant_id, name, slug, parent_id, sort_order, is_active, created_at, updated_at FROM topics WHERE id = $1 AND restaurant_id = $2
`

type GetTopicParams struct {
	ID           int64
	RestaurantID int32
}

func (q *Queries) GetTopic(ctx context.Context, arg GetTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, getTopic, arg.ID, arg.RestaurantID)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Name,
		&i.Slug,
		&i.ParentID,
		&i.SortOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopicsByRestaurant = `-- name: GetTopicsByRestaurant :many
SELECT id, restaurant_id, name, slug, parent_id, sort_order, is_active, created_at, updated_at
FROM topics
WHERE restaurant_id = $1 AND ( $2::text = '' OR name = $2)
ORDER BY sort_order, id
LIMIT $3 OFFSET $4
`

type GetTopicsByRestaurantParams struct {
	RestaurantID int32
	Column2      string
	Limit        int32
	Offset       int32
}

func (q *Queries) GetTopicsByRestaurant(ctx context.Context, arg GetTopicsByRestaurantParams) ([]Topic, error) {
	rows, err := q.db.Query(ctx, getTopicsByRestaurant,
		arg.RestaurantID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.Name,
			&i.Slug,
			&i.ParentID,
			&i.SortOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopicsByRestaurantCombobox = `-- name: GetTopicsByRestaurantCombobox :many
SELECT id as Value, name as TEXT FROM topics WHERE restaurant_id = $1 and is_active = true
`

type GetTopicsByRestaurantComboboxRow struct {
	Value int64
	Text  string
}

func (q *Queries) GetTopicsByRestaurantCombobox(ctx context.Context, restaurantID int32) ([]GetTopicsByRestaurantComboboxRow, error) {
	rows, err := q.db.Query(ctx, getTopicsByRestaurantCombobox, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopicsByRestaurantComboboxRow
	for rows.Next() {
		var i GetTopicsByRestaurantComboboxRow
		if err := rows.Scan(&i.Value, &i.Text); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantsByItem = `-- name: GetVariantsByItem :many
SELECT id, menu_item_id, name, price_delta, is_default, sort_order, created_at, updated_at
FROM menu_item_variants
WHERE menu_item_id = $1
ORDER BY sort_order, id
`

func (q *Queries) GetVariantsByItem(ctx context.Context, menuItemID int64) ([]MenuItemVariant, error) {
	rows, err := q.db.Query(ctx, getVariantsByItem, menuItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItemVariant
	for rows.Next() {
		var i MenuItemVariant
		if err := rows.Scan(
			&i.ID,
			&i.MenuItemID,
			&i.Name,
			&i.PriceDelta,
			&i.IsDefault,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenus = `-- name: ListMenus :many
SELECT
    m.id, m.restaurant_id, m.topic_id, m.type, m.name, m.description, m.image_url, m.sku, m.base_price, m.is_active, m.sort_order, m.created_at, m.updated_at
FROM menu_items m
JOIN topics t ON m.topic_id = t.id
WHERE m.restaurant_id = $1
  AND (NULLIF($2::text, '') IS NULL OR m.type = $2::menu_item_type)
  AND (NULLIF($3::bigint, 0) IS NULL OR m.id < $3)
  AND (COALESCE($4::text[], '{}'::text[]) = '{}' OR t.name = ANY($4))
  AND m.is_active = true
GROUP BY m.id, m.name, m.restaurant_id, m.type
HAVING (COALESCE($4::text[], '{}'::text[]) = '{}' OR COUNT(DISTINCT t.name) = cardinality($4))
ORDER BY m.id DESC
LIMIT $5
`

type ListMenusParams struct {
	RestaurantID int32
	MenuType     string
	Cursor       int64
	TopicNames   []string
	PageSize     int32
}

func (q *Queries) ListMenus(ctx context.Context, arg ListMenusParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listMenus,
		arg.RestaurantID,
		arg.MenuType,
		arg.Cursor,
		arg.TopicNames,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.TopicID,
			&i.Type,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Sku,
			&i.BasePrice,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComboGroup = `-- name: UpdateComboGroup :exec
UPDATE combo_groups
SET
    name = $2,
    min_select = $3,
    max_select = $4,
    sort_order = $5,
    updated_at = NOW()
WHERE id = $1
`

type UpdateComboGroupParams struct {
	ID        int64
	Name      string
	MinSelect int32
	MaxSelect int32
	SortOrder int32
}

func (q *Queries) UpdateComboGroup(ctx context.Context, arg UpdateComboGroupParams) error {
	_, err := q.db.Exec(ctx, updateComboGroup,
		arg.ID,
		arg.Name,
		arg.MinSelect,
		arg.MaxSelect,
		arg.SortOrder,
	)
	return err
}

const updateMenuItem = `-- name: UpdateMenuItem :exec
UPDATE menu_items
SET
    topic_id = $2,
    type = $3,
    name = $4,
    description = $5,
    image_url = $6,
    sku = $7,
    base_price = $8,
    is_active = $9,
    sort_order = $10,
    updated_at = NOW()
WHERE id = $1 and restaurant_id = $11
`

type UpdateMenuItemParams struct {
	ID           int64
	TopicID      *int64
	Type         string
	Name         string
	Description  *string
	ImageUrl     *string
	Sku          *string
	BasePrice    pgtype.Numeric
	IsActive     bool
	SortOrder    int32
	RestaurantID int32
}

func (q *Queries) UpdateMenuItem(ctx context.Context, arg UpdateMenuItemParams) error {
	_, err := q.db.Exec(ctx, updateMenuItem,
		arg.ID,
		arg.TopicID,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.Sku,
		arg.BasePrice,
		arg.IsActive,
		arg.SortOrder,
		arg.RestaurantID,
	)
	return err
}

const updateOptionGroup = `-- name: UpdateOptionGroup :exec
UPDATE option_groups
SET
    name = $3,
    min_select = $4,
    max_select = $5,
    is_required = $6,
    sort_order = $7,
    updated_at = NOW()
WHERE id = $1
  AND restaurant_id = $2
`

type UpdateOptionGroupParams struct {
	ID           int64
	RestaurantID int32
	Name         string
	MinSelect    int32
	MaxSelect    int32
	IsRequired   bool
	SortOrder    int32
}

func (q *Queries) UpdateOptionGroup(ctx context.Context, arg UpdateOptionGroupParams) error {
	_, err := q.db.Exec(ctx, updateOptionGroup,
		arg.ID,
		arg.RestaurantID,
		arg.Name,
		arg.MinSelect,
		arg.MaxSelect,
		arg.IsRequired,
		arg.SortOrder,
	)
	return err
}

const updateOptionItem = `-- name: UpdateOptionItem :exec
UPDATE option_items oi
SET
    name = $2,
    linked_menu_item = $3,
    price_delta = $4,
    quantity_min = $5,
    quantity_max = $6,
    sort_order = $7,
    updated_at = NOW()
FROM option_groups og
WHERE oi.id = $1
  AND oi.option_group_id = og.id
  AND og.restaurant_id = $8
`

type UpdateOptionItemParams struct {
	ID             int64
	Name           *string
	LinkedMenuItem *int64
	PriceDelta     pgtype.Numeric
	QuantityMin    int32
	QuantityMax    int32
	SortOrder      int32
	RestaurantID   int32
}

func (q *Queries) UpdateOptionItem(ctx context.Context, arg UpdateOptionItemParams) error {
	_, err := q.db.Exec(ctx, updateOptionItem,
		arg.ID,
		arg.Name,
		arg.LinkedMenuItem,
		arg.PriceDelta,
		arg.QuantityMin,
		arg.QuantityMax,
		arg.SortOrder,
		arg.RestaurantID,
	)
	return err
}

const updateStatusMenuItem = `-- name: UpdateStatusMenuItem :exec
UPDATE menu_items
SET is_active = $1,
updated_at = NOW()
WHERE id = $2 and restaurant_id = $3
`

type UpdateStatusMenuItemParams struct {
	IsActive     bool
	ID           int64
	RestaurantID int32
}

func (q *Queries) UpdateStatusMenuItem(ctx context.Context, arg UpdateStatusMenuItemParams) error {
	_, err := q.db.Exec(ctx, updateStatusMenuItem, arg.IsActive, arg.ID, arg.RestaurantID)
	return err
}

const updateTopic = `-- name: UpdateTopic :exec
UPDATE topics
SET
    name = $3,
    slug = $4,
    parent_id = $5,
    sort_order = $6,
    updated_at = NOW()
WHERE id = $1
  AND restaurant_id = $2
`

type UpdateTopicParams struct {
	ID           int64
	RestaurantID int32
	Name         string
	Slug         *string
	ParentID     *int64
	SortOrder    int32
}

func (q *Queries) UpdateTopic(ctx context.Context, arg UpdateTopicParams) error {
	_, err := q.db.Exec(ctx, updateTopic,
		arg.ID,
		arg.RestaurantID,
		arg.Name,
		arg.Slug,
		arg.ParentID,
		arg.SortOrder,
	)
	return err
}

const updateVariant = `-- name: UpdateVariant :exec
UPDATE menu_item_variants
SET
    name = $2,
    price_delta = $3,
    is_default = $4,
    sort_order = $5,
    updated_at = NOW()
WHERE id = $1
`

type UpdateVariantParams struct {
	ID         int64
	Name       string
	PriceDelta pgtype.Numeric
	IsDefault  bool
	SortOrder  int32
}

func (q *Queries) UpdateVariant(ctx context.Context, arg UpdateVariantParams) error {
	_, err := q.db.Exec(ctx, updateVariant,
		arg.ID,
		arg.Name,
		arg.PriceDelta,
		arg.IsDefault,
		arg.SortOrder,
	)
	return err
}
