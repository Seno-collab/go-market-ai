// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: restaurants.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const checkUserRestaurant = `-- name: CheckUserRestaurant :one
SELECT 1
FROM restaurant_users
WHERE restaurant_id = $1
  AND user_id = $2
  AND deleted_at IS NULL
LIMIT 1
`

type CheckUserRestaurantParams struct {
	RestaurantID int32
	UserID       uuid.UUID
}

func (q *Queries) CheckUserRestaurant(ctx context.Context, arg CheckUserRestaurantParams) (int32, error) {
	row := q.db.QueryRow(ctx, checkUserRestaurant, arg.RestaurantID, arg.UserID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createRestaurant = `-- name: CreateRestaurant :one
INSERT INTO "restaurants" (name, description, address, category, city, district, logo_url, banner_url, phone_number, website_url, email, created_by)
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id
`

type CreateRestaurantParams struct {
	Name        string
	Description *string
	Address     *string
	Category    *string
	City        *string
	District    *string
	LogoUrl     *string
	BannerUrl   *string
	PhoneNumber *string
	WebsiteUrl  *string
	Email       *string
	CreatedBy   uuid.UUID
}

func (q *Queries) CreateRestaurant(ctx context.Context, arg CreateRestaurantParams) (int32, error) {
	row := q.db.QueryRow(ctx, createRestaurant,
		arg.Name,
		arg.Description,
		arg.Address,
		arg.Category,
		arg.City,
		arg.District,
		arg.LogoUrl,
		arg.BannerUrl,
		arg.PhoneNumber,
		arg.WebsiteUrl,
		arg.Email,
		arg.CreatedBy,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createRestaurantHours = `-- name: CreateRestaurantHours :exec
INSERT INTO "restaurant_hours" (restaurant_id, day_of_week, open_time, close_time)
VALUES($1, $2, $3, $4)
`

type CreateRestaurantHoursParams struct {
	RestaurantID int32
	DayOfWeek    int32
	OpenTime     string
	CloseTime    string
}

func (q *Queries) CreateRestaurantHours(ctx context.Context, arg CreateRestaurantHoursParams) error {
	_, err := q.db.Exec(ctx, createRestaurantHours,
		arg.RestaurantID,
		arg.DayOfWeek,
		arg.OpenTime,
		arg.CloseTime,
	)
	return err
}

const getById = `-- name: GetById :many
SELECT
    rs.id,
    rs.name,
    rs.description,
    rs.address,
    rs.category,
    rs.city,
    rs.district,
    rs.logo_url,
    rs.banner_url,
    rs.phone_number,
    rs.website_url,
    rs.email,
    rs.created_by,
    rsh.day_of_week,
    rsh.open_time,
    rsh.close_time
FROM "restaurants" rs
INNER JOIN "restaurant_hours" rsh ON rs.id = rsh.restaurant_id
WHERE id = $1 AND rs.deleted_at IS NULL
`

type GetByIdRow struct {
	ID          int32
	Name        string
	Description *string
	Address     *string
	Category    *string
	City        *string
	District    *string
	LogoUrl     *string
	BannerUrl   *string
	PhoneNumber *string
	WebsiteUrl  *string
	Email       *string
	CreatedBy   uuid.UUID
	DayOfWeek   int32
	OpenTime    string
	CloseTime   string
}

func (q *Queries) GetById(ctx context.Context, id int32) ([]GetByIdRow, error) {
	rows, err := q.db.Query(ctx, getById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetByIdRow
	for rows.Next() {
		var i GetByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Address,
			&i.Category,
			&i.City,
			&i.District,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.PhoneNumber,
			&i.WebsiteUrl,
			&i.Email,
			&i.CreatedBy,
			&i.DayOfWeek,
			&i.OpenTime,
			&i.CloseTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByName = `-- name: GetByName :many
SELECT
    rs.id,
    rs.name,
    rs.description,
    rs.address,
    rs.category,
    rs.city,
    rs.district,
    rs.logo_url,
    rs.banner_url,
    rs.phone_number,
    rs.website_url,
    rs.email,
    rs.created_by,
    rsh.day_of_week,
    rsh.open_time,
    rsh.close_time
FROM "restaurants" rs
INNER JOIN "restaurant_hours" rsh ON rs.id = rsh.restaurant_id
WHERE name LIKE $1 AND rs.deleted_at IS NULL
`

type GetByNameRow struct {
	ID          int32
	Name        string
	Description *string
	Address     *string
	Category    *string
	City        *string
	District    *string
	LogoUrl     *string
	BannerUrl   *string
	PhoneNumber *string
	WebsiteUrl  *string
	Email       *string
	CreatedBy   uuid.UUID
	DayOfWeek   int32
	OpenTime    string
	CloseTime   string
}

func (q *Queries) GetByName(ctx context.Context, name string) ([]GetByNameRow, error) {
	rows, err := q.db.Query(ctx, getByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetByNameRow
	for rows.Next() {
		var i GetByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Address,
			&i.Category,
			&i.City,
			&i.District,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.PhoneNumber,
			&i.WebsiteUrl,
			&i.Email,
			&i.CreatedBy,
			&i.DayOfWeek,
			&i.OpenTime,
			&i.CloseTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRestaurantByUserID = `-- name: GetRestaurantByUserID :one
SELECT restaurant_id FROM restaurant_users WHERE user_id = $1
`

func (q *Queries) GetRestaurantByUserID(ctx context.Context, userID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getRestaurantByUserID, userID)
	var restaurant_id int32
	err := row.Scan(&restaurant_id)
	return restaurant_id, err
}

const getRestaurantItemsCombobox = `-- name: GetRestaurantItemsCombobox :many
SELECT rs.id AS value, rs.name AS text FROM "restaurants" rs
INNER JOIN "restaurant_users" ru ON rs.id = ru.restaurant_id
WHERE ru.user_id = $1 AND rs.deleted_at IS NULL AND status = 'active'
`

type GetRestaurantItemsComboboxRow struct {
	Value int32
	Text  string
}

func (q *Queries) GetRestaurantItemsCombobox(ctx context.Context, userID uuid.UUID) ([]GetRestaurantItemsComboboxRow, error) {
	rows, err := q.db.Query(ctx, getRestaurantItemsCombobox, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRestaurantItemsComboboxRow
	for rows.Next() {
		var i GetRestaurantItemsComboboxRow
		if err := rows.Scan(&i.Value, &i.Text); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteRestaurant = `-- name: SoftDeleteRestaurant :exec
UPDATE restaurants
SET deleted_at = NOW(), updated_by = $1, status = 'inactive'
WHERE id = $2
`

type SoftDeleteRestaurantParams struct {
	UpdatedBy uuid.UUID
	ID        int32
}

func (q *Queries) SoftDeleteRestaurant(ctx context.Context, arg SoftDeleteRestaurantParams) error {
	_, err := q.db.Exec(ctx, softDeleteRestaurant, arg.UpdatedBy, arg.ID)
	return err
}

const softDeleteRestaurantHours = `-- name: SoftDeleteRestaurantHours :exec
UPDATE "restaurant_hours"
SET deleted_at = NOW()
WHERE restaurant_id = $1
`

func (q *Queries) SoftDeleteRestaurantHours(ctx context.Context, restaurantID int32) error {
	_, err := q.db.Exec(ctx, softDeleteRestaurantHours, restaurantID)
	return err
}

const softDeleteRestaurantUser = `-- name: SoftDeleteRestaurantUser :exec
UPDATE restaurant_users
SET deleted_at = NOW(),
    updated_at = NOW()
WHERE restaurant_id = $1 AND user_id = $2
`

type SoftDeleteRestaurantUserParams struct {
	RestaurantID int32
	UserID       uuid.UUID
}

func (q *Queries) SoftDeleteRestaurantUser(ctx context.Context, arg SoftDeleteRestaurantUserParams) error {
	_, err := q.db.Exec(ctx, softDeleteRestaurantUser, arg.RestaurantID, arg.UserID)
	return err
}

const updateRestaurant = `-- name: UpdateRestaurant :exec
UPDATE "restaurants"
SET name = $1, description = $2, address = $3,
    category = $4, city = $5, district = $6,
    logo_url = $7, banner_url = $8, phone_number = $9,
    website_url = $10, email = $11, updated_by = $12
WHERE id = $13
`

type UpdateRestaurantParams struct {
	Name        string
	Description *string
	Address     *string
	Category    *string
	City        *string
	District    *string
	LogoUrl     *string
	BannerUrl   *string
	PhoneNumber *string
	WebsiteUrl  *string
	Email       *string
	UpdatedBy   uuid.UUID
	ID          int32
}

func (q *Queries) UpdateRestaurant(ctx context.Context, arg UpdateRestaurantParams) error {
	_, err := q.db.Exec(ctx, updateRestaurant,
		arg.Name,
		arg.Description,
		arg.Address,
		arg.Category,
		arg.City,
		arg.District,
		arg.LogoUrl,
		arg.BannerUrl,
		arg.PhoneNumber,
		arg.WebsiteUrl,
		arg.Email,
		arg.UpdatedBy,
		arg.ID,
	)
	return err
}

const upsertRestaurantUser = `-- name: UpsertRestaurantUser :exec
INSERT INTO restaurant_users (
    restaurant_id, user_id, role, created_at, updated_at
)
VALUES ($1, $2, $3, NOW(), NOW())
ON CONFLICT (restaurant_id, user_id)
DO UPDATE SET
    role = EXCLUDED.role,
    updated_at = NOW()
`

type UpsertRestaurantUserParams struct {
	RestaurantID int32
	UserID       uuid.UUID
	Role         string
}

func (q *Queries) UpsertRestaurantUser(ctx context.Context, arg UpsertRestaurantUserParams) error {
	_, err := q.db.Exec(ctx, upsertRestaurantUser, arg.RestaurantID, arg.UserID, arg.Role)
	return err
}
